from common.benchmark_wrapper import BenchmarkWrapper
import json
import subprocess
import os


class BlenderBenchmark(BenchmarkWrapper):

    """
    This is a Blender benchmark implementation.
    """

    def __init__(self):
        self._settings = {}
        self.filePath = os.path.dirname(__file__)
        self.baseCommand = "benchmark-launcher-cli"

    def setSettings(self, settings_file):
        self._settings = json.load(open(settings_file, "r"))

    def startBenchmark(self, verbosity=None):
        self.getSettings(("blender", "download"))
        self.getSettings(("scenes", "download"))
        self.scenes = " ".join([str(elem) for elem in self._settings["scenes"]])
        self.verbosity = verbosity
        if self.verbosity == None:
            self.verbosity = self._settings["verbosity"]

        try:
            print(self.verbosity)
            startBench = subprocess.run(
                [
                    os.path.join(self.filePath, self.baseCommand),
                    "benchmark",
                    str(self.scenes),
                    "-b",
                    str(self._settings["blender_version"]),
                    "--device-type",
                    str(self._settings["device_type"]),
                    "--json",
                    "-v",
                    str(self.verbosity),
                ]
            )
        except subprocess.CalledProcessError as e:
            print(e.output)
            exit
        if startBench.returncode != 0:
            print(startBench.stderr)

    def benchmarkStatus():
        pass

    def getSettings(self, args):
        commands = {
            "blender": {  # Container Dictionary for blender download managerc
                "download": [  # Downloads the blender version specified in the settings
                    os.path.join(self.filePath, self.baseCommand),
                    "blender",
                    "download",
                    str(self._settings["blender_version"]),
                ],
                "list": [  # Lists available blender versions
                    os.path.join(self.filePath, self.baseCommand),
                    "blender",
                    "list",
                ],
            },
            "devices": [  # Prints compatible devices
                os.path.join(self.filePath, self.baseCommand),
                "devices",
                "-b",
                str(self._settings["blender_version"]),
            ],
            "help": [  # Prints the help window
                os.path.join(self.filePath, self.baseCommand),
                "--help",
            ],
            "scenes": {  # Container Dictionary for scenes download manager
                "download": [  # Downloads the scenes mentioned in settings
                    os.path.join(self.filePath, self.baseCommand),
                    "scenes",
                    "download",
                    "-b",
                    str(self._settings["blender_version"]),
                ]
                + (self._settings["scenes"]),
                "list": [  # Lists scenes
                    os.path.join(self.filePath, self.baseCommand),
                    "scenes",
                    "list",
                    "-b",
                    str(self._settings["blender_version"]),
                ],
            },
            "clear_cache": [  # Clears cache generated by the blender cli
                os.path.join(self.filePath, self.baseCommand),
                "clear_cache",
            ],
        }
        if len(args) == 2:
            if args[1] == "help":
                command = [os.path.join(self.filePath, self.baseCommand)] + [
                    args[0],
                    "help",
                ]
            else:
                command = commands.get(args[0]).get(args[1])
        elif len(args) == 1:
            command = commands.get(args[0])
        else:
            raise Exception("Please check your command and enter again")
        try:
            process = subprocess.Popen(command, stdout=subprocess.PIPE)
        except KeyError as e:
            print(e.output)
        if args[0] == "devices":
            p2 = subprocess.Popen(
                ["grep", "CUDA\|OPTIX"], stdin=process.stdout, stdout=subprocess.PIPE
            )
            process.stdout.close()
            print(p2.communicate()[0].decode())
        else:
            print(process.communicate()[0].decode())

    def stopBenchmark():
        pass


"""
TODO:[Logger Output after parsing]
[
  {
    "stats": {
      "device_peak_memory": 146,
      "total_render_time": 208.673,
      "render_time_no_sync": 206.112
    }
    "timestamp": "2021-07-11T09:00:52.938463+00:00",
    "blender_version": {
      "label": "2.92",                                                                            
      "checksum": "2cd17ad6e9d6c241ac14b84ad6e72b507aeec979da3d926b1a146e88e0eb3eb4"
    },
    "benchmark_launcher": {
      "label": "2.0.5",
      "checksum": "0513a4a626bb0ee387366f67a632ea0f886ee5906aaafe148d473842059fb2ec"
    },
    "benchmark_script": {
      "label": "2.0.1",
      "checksum": "dee17c82d883838f6da21e7c86f368cda2ab8399eac10b660e199628aca09ec0"
    },
    "scene": {
      "label": "bmw27",
      "checksum": "bc4fd79cbd85a1cc47926e848ec8f322872f5c170ef33c21e0d0ce303c0ec9ea"
    },
  }
]
"""
